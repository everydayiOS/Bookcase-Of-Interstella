## MVVM



<img src="https://i.imgur.com/vdeHgws.png" style="zoom:50%;" />



\- Models — emit notifications about data changes. 다른 클래스들과 직접적으로 이야기하지 않는다.

\- View Models — 모델과 통신하고, 뷰 컨트롤러에게 데이터를 노출한다.

\- 뷰 컨트롤러는 뷰모델과 뷰들과만 이야기한다. 뷰 라이프사이클을 관리하며 데이터를 UI component들에 바인딩한다.

\- Views — MVC에서와 같이 뷰 컨트롤러들에게 이벤트를 알리기만 한다.



### MVVM의 장점



- 코드의 테스트 용이성이 증가한다.

- 뷰모델이 presentation layer와 완전히 분리되어서, 플랫폼 간 재사용이 가능하다. view-view controller pair만 교체하면 iOS에서 macOS, tvOS 등으로 앱을 이전시킬 수 있다.

### ViewModel의 역할

- 데이터와 화면 사이의 brain.

- MVVM에서는, MVVM의 카테고리들 중 어느 곳에도 맞지 않는 networking, navigation, cache 등의 다른 기능들에 대한 규칙을 강제하지는 않는다. 이 챕터에서는 이 기능들에 대해 몇몇 가능한 솔루션들을 소개한다.

### 객체별 역할

> 컨트롤러의 역할



- View, Model, ViewModel을 모두 알고 있으면서 매개체 역할을 한다. 다만 주의할 점은 하위 객체들이 서로 직접적으로 구체 타입을 참조하지 않고 독립적으로 동작하도록 해야 한다.

- 뷰와 모델 사이를 끊어주는 역할이 중요하다.

- 뷰 컨트롤러는 화면과, 화면에 필요한 데이터의 흐름을 제어하는 역할을 하는 데 집중한다.



> 데이터소스와 델리게이트, 뷰모델



DataSource와 Delegate는 같을 수도 있고 다를 수도 있다. 하지만 하나의 객체가 두 가지 역할을 한다고 해서 흐름이 서로 섞이면 안된다. 예를 들어,



- 델리게이트 이벤트를 처리하는 코드에서 데이터소스의 역할을 하거나, 데이터소스에서 델리게이트 이벤트 처리를 위한 메서드를 호출하면 안된다.

- 데이터소스도 뷰가 보여줘야 하는 데이터를 갖고 있으므로 역할로 보면 뷰모델이다. 그러므로 데이터소스를 따로 만들려고 하지 않아도 되고, 뷰모델 객체가 데이터소스 프로토콜을 채택해도 된다. 또는 델리게이트 역할을 할 수도 있다.



**델리게이트는 모델 값을 업데이트하기만 하고, 데이터소스는 모델 값을 읽기만 한다.** 데이터소스가 값을 변경하면 이상한 것이다. 뷰모델을 안 만들면 델리게이트와 데이터소스를 만든다. 하나의 객체여도 된다. 다만 흐름은 꼭 분리한다.



모델 값을 업데이트하는 흐름과, 모델 값에 따라서 뷰를 변경하는 흐름을 분리하라는 말인데, 이런 분리를 하지 않으면, 중복되는 코드가 마구 생기게 될 수 있다는 생각이 든다.

예를 들어 어떤 버튼을 눌렀을 때와, 네트워크를 통해 어떤 값이 도착했을 때 특정 뷰를 빨간색으로 칠해야 한다면, 어떤 버튼을 눌렀을 때의 코드에도 뷰를 빨간색으로 칠하는 코드가 들어가고, 네트워크를 통해 값이 도착했을 때 동작하는 코드에도 뷰를 빨간색으로 칠하는 코드가 들어간다. 이렇게 중복되는 코드가 생긴다.

코드의 중복 면에서도 좋지 않고, 또 좋지 않은 점은 이런 식으로 하나의 뷰를 건드리는 코드가 여러 곳이라면, 오동작의 소지가 있고, 디버깅도 쉽지 않다. 뷰가 원치 않는 색상을 표시하고 있을 때, 원인을 찾으려면 분산되어있는 코드 여러 곳을 살펴봐야 한다.



> ViewModel과 View의 관계



***이벤트에 따른 데이터 업데이트 흐름**이 중요하다. 뷰모델과 뷰의 관계는 다음 두 가지 정도로 이루어진다.



1. 사용자 액션에 따른 이벤트(보통 델리게이트)

2. 모델 업데이트에 따라 뷰 업데이트(보통 데이터소스)



1, 2의 흐름을 각각 Bind할 수 있어야 MVVM Bind가 되는 것이다. iOS에서는 완벽한 바인딩이 불가능하지만, 데이터소스와 델리게이트로 그 역할을 나누도록 가이드하는 것이다. (SwiftUI + Combine 수준에서는 가능하기도 함)



> Action 또는 델리게이트 연결 시 주의할 사항



- 액션을 연결할 때 주의할 사항은 액션-이벤트에 따라 어떤 모델의 값을 변경하게 되는가를 우선적으로 생각한다.

- 액션에 따라 모델이 바뀌면 화면이 바뀌는 것까지 액션에서 처리하지 말 것. 모델이 바뀌면 화면이 바뀌는 흐름(바인딩, 노티를 통한 업데이트 등)을 별도로 만들어 놓고, 액션에서는 모델만 바꾼다. 예를 들어, 자판기로 생각해보면 버튼을 눌러 잔액을 추가하는 기능의 경우,

​    - 버튼을 눌러 잔액을 추가하면, 잔액 모델만 변경

​    - 잔액이 변경되면, 알림을 받아 화면을 업데이트



​    이렇게 ***화면 액션(이벤트) → 모델 변경** 흐름과 ***모델 업데이트(알림) → 화면 변경** 흐름을 구분지어 분리하는 것이 중요하다.



정리하면, **뷰에서 이벤트를 받아주는 IBAction 또는 델리게이트 객체에서는 필요한 모델을 변경하는 흐름**과, **모델이 바뀌면 노티, 클로저, didSet, KVO, Publisher 뭐든지간에 다른 모듈에서 받아서 뷰를 업데이트하는 흐름**을 구분해야 한다.